import { Bindings, GraphType, ObjectType, PredicateType, SubjectType } from './types';
import { Quad_Graph, Quad_Object, Quad_Predicate, Quad, Quad_Subject, Term } from './tf-types';
/** A Statement represents an RDF Triple or Quad. */
export default class Statement implements Quad<SubjectType, PredicateType, ObjectType, GraphType> {
    /** The subject of the triple.  What the Statement is about. */
    subject: SubjectType;
    /** The relationship which is asserted between the subject and object */
    predicate: PredicateType;
    /** The thing or data value which is asserted to be related to the subject */
    object: ObjectType;
    /**
     * The graph param is a named node of the document in which the triple when
     *  it is stored on the web.
     */
    graph: GraphType;
    /**
     * Construct a new statement
     *
     * @param subject - The subject of the triple.  What the fact is about
     * @param predicate - The relationship which is asserted between the subject and object
     * @param object - The thing or data value which is asserted to be related to the subject
     * @param {NamedNode} graph - The document where the triple is or was or will be stored on the web.
     *
     * The graph param is a named node of the document in which the triple when it is stored
     *  on the web. It exists because when you have read data from various places in the web,
     *  the “graph” tells you _why_ you have the triple. (At the moment, it is just the
     *  document, in future it could be an inference step)
     *
     * When you do UpdateManager.update() then the graph’s of all the statements must be the same,
     *  and give the document you are patching. In future, we may have a more
     *  powerful update() which can update more than one document.
     */
    constructor(subject: Quad_Subject | Term, predicate: Quad_Predicate | Term, object: Quad_Object | Term, graph?: Quad_Graph | Term);
    /** @deprecated use {graph} instead */
    get why(): GraphType;
    set why(g: GraphType);
    /**
     * Checks whether two statements are the same
     * @param other - The other statement
     */
    equals(other: Quad): boolean;
    /**
     * Creates a statement with the bindings substituted
     * @param bindings The bindings
     */
    substitute(bindings: Bindings): Statement;
    /** Creates a canonical string representation of this statement. */
    toCanonical(): string;
    /** Creates a n-triples string representation of this statement */
    toNT(): string;
    /** Creates a n-quads string representation of this statement */
    toNQ(): string;
    /** Creates a string representation of this statement */
    toString(): string;
}
